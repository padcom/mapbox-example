<template>
  <div ref="map" class="map"></div>
</template>

<script lang="ts">
import { v4 as uuid } from 'uuid'
import { BBox, Feature, Point, Position } from 'geojson'
import { Expression, GeoJSONSource, Map, MapboxGeoJSONFeature } from 'mapbox-gl'
import { defineComponent } from 'vue'
import Supercluster, { PointFeature } from 'supercluster'

type Nullable<T> = T | null

async function waitForEvent(
  obj: { once(event: string, handler: () => void): unknown },
  event: string,
  { timeout = 1000 } = {}
) {
  return new Promise((resolve, reject) => {
    const timeoutTimer = setTimeout(() => {
      cleanup()
      reject('Timeout')
    }, timeout)

    obj.once(event, () => {
      cleanup()
      resolve(true)
    })

    function cleanup() {
      clearTimeout(timeoutTimer)
    }
  })
}

export default defineComponent({
  setup() {
    return { map: null as Nullable<Map> }
  },
  async mounted() {
    this.demo3()
  },
  beforeUnmount() {
    this.map?.remove()
  },
  methods: {
    async demo1() {
      this.map = new Map({
        container: this.$refs.map as HTMLElement,
        style: 'mapbox://styles/mapbox/streets-v11',
        center: [18.656409506876486, 50.32529164143756],
        zoom: 10
      })

      await waitForEvent(this.map, 'load')

      // Input marker data
      const markers = [
        { id: 'a', location: [18.656409506876486, 50.32276164243756], value: 'abc' },
        { id: 'b', location: [18.655409506876486, 50.32776164243756], value: 'xyz' },
      ]

      // Mapping function that takes a MarkerDef and converts it to GeoJSON Feature object
      const toPointFeature = (marker: { id: string, location: Position, value: string }) => ({
        type: 'Feature',
        id: crypto.randomUUID(),
        geometry: {
          type: 'Point',
          coordinates: marker.location,
        },
        properties: {
          id: marker.id,
          value: marker.value,
        }
      } as Feature)

      // This is the collection of all the features.
      // Each feature is a single marker
      this.map.addSource('markers', {
        type: 'geojson',
        generateId: true,
        data: {
          type: 'FeatureCollection',
          features: markers.map(toPointFeature),
        }
      })

      // Adding more features is possible by using the "setData" method that
      // takes all of features and replaces the "data".
      const source = this.map.getSource('markers') as GeoJSONSource
      // source.setData({
      //   type: 'FeatureCollection',
      //   features: markers.map(toPointFeature),
      // })

      const ifFeatureStateElse = <T>(state: string, trueValue: T, falseValue: T) => ([
        // case is simple: [case, condition, true-value, false-value]
        'case',
        // This logic is a bit twisted but it actually makes sense
        // There are 2 states to the "hover" key. One is 'non-existent'
        // and the other is hover: true.
        // Initially all features have the state non-existent.
        // The "boolean" operand is: [boolean, [exp], fallback] and returns a bool
        // It is in essence a type-casting operator so that whatever the feature-state
        // type is it will always return a boolean
        // The "fallback" value is provided if the "feature-state" is missing
        // from that feature - hence the last parameter is false
        ['boolean', ['feature-state', state], false],
        trueValue,
        falseValue
      ] as Expression)

      // This is an interesting construct. A "Layer" in mapbox is sort of a view
      // on the data. You specify from which source the data should come ('source'),
      // which elements from the source should be presented ('filter')
      // and how the presentation should be done ('paint')
      //
      // When specifying painting option one can use expression `feature-state` which
      // returns the given key from feature's state. You can manipulate the feature's
      // state by using the following call:
      //
      // map.setFeatureState({ id: <autogenerated_id>, source: <id>) }, { state: value })
      //
      this.map?.addLayer({
        id: `markers`,
        type: 'circle',
        source: 'markers',
        paint: {
          "circle-radius": ifFeatureStateElse('hover', 50, 25),
          "circle-color": ifFeatureStateElse('hover', 'red', 'green'),
          "circle-opacity": ifFeatureStateElse('hover', 0.8, 0.5),
        },
        // filter: ['==', ['get', 'value'], 'abc'],
      })

      // Highlighting is done by setting the "hover" state of a feature to "true"
      const highlight = (feature: MapboxGeoJSONFeature) => {
        this.map?.setFeatureState(feature, { hover: true })
      }

      // Removing the highlight is done either by setting the "hover" state to "false"
      // or by completely removing the assiciated state in which case the "fallback"
      // in "boolean" filters will kick in and provide the "false" value without having
      // to store it
      const unhighlight = (feature: MapboxGeoJSONFeature) => {
        // set hover: false
        this.map?.setFeatureState(feature, { hover: false })
        // or remove the feature state completely
        this.map?.removeFeatureState({ id: feature.id, source: feature.source })
      }

      // Extracts the first feature from the given event
      function featureFromEvent(event: { features?: MapboxGeoJSONFeature[] }) {
        return event?.features && event?.features.length > 0 ? event.features[0] : null
      }

      // This is an array holding a list of all currently highlighted features (as in "markers")
      // It'd be awesome if we could query the list of highlighted features directly from the layer
      // but unfortunately it doesn't work. See the note about error message in 'mouseout' handler
      let highlightedFeature: Nullable<MapboxGeoJSONFeature> = null

      // The "mouseover" and "mouseout" events are kind enough to provide us with the list
      // of features that have been hovered by the user

      // When the user enters with the mouse over a particular feature we want to get
      // a list of all the features that have been touched
      this.map?.on('mouseover', 'markers', e => {
        // This is how we're getting the first feature that has been hovered
        highlightedFeature = featureFromEvent(e)
        // Now let's ensure it is highlighted
        if (highlightedFeature) highlight(highlightedFeature)
      })
      this.map?.on('mouseout', 'markers', e => {
        // Unfortunately this doesn't work. It throws the following exception:
        //
        // Error: querySourceFeatures.filter: "feature-state" data expressions are not supported with filters.
        //
        // const highlightedFeatures = this.map?.querySourceFeatures('markers', {
        //   sourceLayer: 'markers',
        //   filter: [ '==', [ 'feature-state', 'hover' ], true ]
        // })

        // If by any chance we did store a reference to the currently highlighted marker
        // we shall unhighlight it and remove all traces of that previous information at once!
        if (highlightedFeature) {
          unhighlight(highlightedFeature)
          highlightedFeature = null
        }
      })

      // The "click" event isn't as gentle with the developer
      // and requires us to query the features from the given layers
      this.map?.on('click', e => {
        const feature = featureFromEvent({ features: this.map?.queryRenderedFeatures(e.point, { layers: ['markers'] }) })
        if (feature) {
          console.log('Feature', feature, 'clicked')
        } else {
          console.log('Clicked on nothing at', e.point)
        }
      })
    },
    async demo2() {
      //
      // 200k clustered markers using Supercluster (I think that's what is used behind the scenes)
      //

      console.time('Initialization')

      this.map = new Map({
        container: this.$refs.map as HTMLElement,
        style: 'mapbox://styles/mapbox/streets-v11',
        // center: [18.656409506876486, 50.32529164143756],
        center: [8.1, 46.8],
        // zoom: 10
        zoom: 7.5
      })

      // make sure we wait for the map to initialize
      await waitForEvent(this.map, 'load')

      // Supercluster speaks GeoJSON so we create a GeoJSON source
      // with an empty FeatureCollection.
      this.map.addSource('markers', {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: []
        }
      });

      // Create layer for actual markers
      this.map.addLayer({
        id: 'markers',
        type: 'symbol',
        source: 'markers',
        filter: ['!', ['has', 'point_count']],
        layout: {
          'icon-image': 'tw-provincial-expy-2',
          'icon-anchor': 'bottom'
        }
      });

      // Create 2 layers for the clusters:
      // Circle with matching size
      this.map.addLayer({
        id: 'cluster',
        type: 'circle',
        source: 'markers',
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': ['step', ['get', 'point_count'], '#51bbd6', 100, '#f1f075', 750, '#f28cb1'],
          'circle-radius': ['step', ['get', 'point_count'], 20, 100, 30, 750, 40]
        }
      });
      // Number of clustered markers
      this.map.addLayer({
        id: 'cluster-count',
        type: 'symbol',
        source: 'markers',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': '{point_count_abbreviated}',
          'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
          'text-size': 12
        }
      });

      let highlightedMarkerId = null as Nullable<string | number | undefined>

      this.map.on('mouseenter', 'markers', (e) => {
        if (!e || !e.features) return;
        highlightedMarkerId = e.features[0].id
        this.map!.setLayoutProperty('markers', 'icon-image', [
          'match', ['id'], e.features[0].id,
          'tw-provincial-2',
          'tw-provincial-expy-2'
        ]);
      });

      this.map.on('mouseleave', 'markers', () => {
        if (!highlightedMarkerId) return

        this.map!.setLayoutProperty(
          'markers',
          'icon-image',
          'tw-provincial-expy-2'
        );
      });

      console.timeEnd('Initialization')

      const NUMBER_OF_MARKERS = 500000
      const home = this.map.getCenter()

      console.time('Creating ' + NUMBER_OF_MARKERS + ' random marker points')
      const markers = new Array(NUMBER_OF_MARKERS).fill({ lat: 0, lon: 0, id: 0 }).map(marker => {
        const r = 1 * Math.sqrt(Math.random())
        const theta = Math.random() * 2 * Math.PI

        return {
          id: uuid(),
          lat: home.lat + r * Math.cos(theta),
          lon: home.lng + r * Math.sin(theta) * 2,
        }
      })
      console.timeEnd('Creating ' + NUMBER_OF_MARKERS + ' random marker points')

      const source = this.map.getSource('markers') as GeoJSONSource

      function hash(str: string) {
        let result = 5381
        let i = str.length
        while (i) result = (result * 33) ^ str.charCodeAt(--i)

        return result >>> 0
      }

      // Mapping function that takes a MarkerDef and converts it to GeoJSON Feature object
      const toPointFeature = (marker: { id: string | number, lat: number, lon: number }) => ({
        type: 'Feature',
        // id needs to be a number so we take whatever was there and calculate it's hash
        id: hash(marker.id.toString()),
        geometry: {
          type: 'Point',
          coordinates: [marker.lon, marker.lat],
        },
        properties: {
          id: marker.id,
        }
      } as Feature)

      console.time('Converting data to features of ' + markers.length + ' markers (markers.map(toPointFeature))')
      const data = markers.map(toPointFeature)
      console.timeEnd('Converting data to features of ' + markers.length + ' markers (markers.map(toPointFeature))')

      console.time('Creating supercluster')
      const supercluster = new Supercluster({
        log: true,
        radius: 100,
        extent: 128,
        minZoom: 4,
        maxZoom: 14
      }).load(data as PointFeature<any>[])
      console.timeEnd('Creating supercluster')

      const update = async () => {
        console.time('Updating mapbox with ' + markers.length + ' markers (source.setData())')
        console.time('Including waiting for "idle" event')
        const bbox: BBox = this.map!.getBounds().toArray().flat() as BBox
        console.log('bbox', bbox)
        const zoom = this.map!.getZoom()
        console.log('zoom', zoom)
        const clusters = supercluster.getClusters(bbox, zoom)
        console.log('clusters', clusters)
        source.setData({
          type: 'FeatureCollection',
          features: clusters
        })
        console.timeEnd('Updating mapbox with ' + markers.length + ' markers (source.setData())')
        await waitForEvent(this.map!, 'idle', { timeout: 10000 })
        console.timeEnd('Including waiting for "idle" event')
      }

      update()

      this.map!.on('moveend', update)
    },
    async demo3() {
      console.time('Initialization')

      this.map = new Map({
        container: this.$refs.map as HTMLElement,
        style: 'mapbox://styles/mapbox/streets-v11',
        center: [8.1, 46.8],
        zoom: 7.5
      })

      // make sure we wait for the map to initialize
      await waitForEvent(this.map, 'load', { timeout: 10000 })

      // Supercluster speaks GeoJSON so we create a GeoJSON source
      // with an empty FeatureCollection.
      this.map.addSource('markers', {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: []
        }
      });

      // Create layer for actual markers
      this.map.addLayer({
        id: 'markers',
        type: 'symbol',
        source: 'markers',
        filter: ['!', ['has', 'point_count']],
        layout: {
          'icon-image': 'tw-provincial-expy-2',
          'icon-anchor': 'bottom'
        }
      });

      // Create 2 layers for the clusters:
      // Circle with matching size
      this.map.addLayer({
        id: 'cluster',
        type: 'circle',
        source: 'markers',
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': ['step', ['get', 'point_count'], '#51bbd6', 100, '#f1f075', 750, '#f28cb1'],
          'circle-radius': ['step', ['get', 'point_count'], 20, 100, 30, 750, 40]
        }
      });
      // Number of clustered markers
      this.map.addLayer({
        id: 'cluster-count',
        type: 'symbol',
        source: 'markers',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': '{point_count_abbreviated}',
          'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
          'text-size': 12
        }
      });

      const update = async () => {
        console.time('Including waiting for "idle" event')
        const source = this.map!.getSource('markers') as GeoJSONSource
        const bbox: BBox = this.map!.getBounds().toArray().flat() as BBox
        const zoom = this.map!.getZoom()
        const url = `http://localhost:9000/${bbox[0]},${bbox[1]},${bbox[2]},${bbox[3]}/${zoom}`
        const clusters = await fetch(url).then(response => response.json())
        source.setData({
          type: 'FeatureCollection',
          features: clusters
        })
        await waitForEvent(this.map!, 'idle', { timeout: 10000 })
        console.timeEnd('Including waiting for "idle" event')
      }

      update()

      this.map!.on('moveend', update)
    }
  }
})
</script>

<style>
html,
body {
  margin: 0;
  padding: 0;
}

.map {
  height: 100vh;
}
</style>
