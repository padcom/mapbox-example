<template>
  <div ref="map" class="map"></div>
</template>

<script lang="ts">
import { Feature, Position } from 'geojson'
import { Expression, GeoJSONSource, Map, MapboxGeoJSONFeature } from 'mapbox-gl'
import { defineComponent } from 'vue'

type Nullable<T> = T | null

async function waitForEvent(
  obj: { once(event: string, handler: () => void): unknown },
  event: string,
  { timeout = 1000 } = {}
) {
  return new Promise((resolve, reject) => {
    const timeoutTimer = setTimeout(() => {
      cleanup()
      reject('Timeout')
    }, timeout)

    obj.once(event, () => {
      cleanup()
      resolve(true)
    })

    function cleanup() {
      clearTimeout(timeoutTimer)
    }
  })
}

export default defineComponent({
  setup() {
    return { map: null as Nullable<Map> }
  },
  async mounted() {
    this.map = new Map({
      container: this.$refs.map as HTMLElement,
      style: 'mapbox://styles/mapbox/streets-v11',
      center: [18.656409506876486, 50.32529164143756],
      zoom: 15
    })

    await waitForEvent(this.map, 'load')

    // Input marker data
    const markers = [
      { id: 'a', location: [18.656409506876486, 50.32276164243756], value: 'abc' },
      { id: 'b', location: [18.655409506876486, 50.32776164243756], value: 'xyz' },
    ]

    // Mapping function that takes a MarkerDef and converts it to GeoJSON Feature object
    const toPointFeature = (marker: { id: string, location: Position, value: string }) => ({
      type: 'Feature',
      geometry: {
        type: 'Point',
        coordinates: marker.location,
      },
      properties: {
        id: marker.id,
        value: marker.value,
      }
    } as Feature)

    // This is the collection of all the features.
    // Each feature is a single marker
    this.map.addSource('markers', {
      type: 'geojson',
      generateId: true,
      data: {
        type: 'FeatureCollection',
        features: markers.map(toPointFeature),
      }
    })

    // Adding more features is possible by using the "setData" method that
    // takes all of features and replaces the "data".
    const source = this.map.getSource('markers') as GeoJSONSource
    source.setData({
      type: 'FeatureCollection',
      features: markers.map(toPointFeature),
    })

    const ifFeatureStateElse = <T>(state: string, trueValue: T, falseValue: T) => ([
      // case is simple: [case, condition, true-value, false-value]
      'case',
      // This logic is a bit twisted but it actually makes sense
      // There are 2 states to the "hover" key. One is 'non-existent'
      // and the other is hover: true.
      // Initially all features have the state non-existent.
      // The "boolean" operand is: [boolean, [exp], fallback] and returns a bool
      // It is in essence a type-casting operator so that whatever the feature-state
      // type is it will always return a boolean
      // The "fallback" value is provided if the "feature-state" is missing
      // from that feature - hence the last parameter is false
      ['boolean', ['feature-state', state], false],
      trueValue,
      falseValue
    ] as Expression)

    // This is an interesting construct. A "Layer" in mapbox is sort of a view
    // on the data. You specify from which source the data should come ('source'),
    // which elements from the source should be presented ('filter')
    // and how the presentation should be done ('paint')
    //
    // When specifying painting option one can use expression `feature-state` which
    // returns the given key from feature's state. You can manipulate the feature's
    // state by using the following call:
    //
    // map.setFeatureState({ id: <autogenerated_id>, source: <id>) }, { state: value })
    //
    this.map?.addLayer({
      id: `markers`,
      type: 'circle',
      source: 'markers',
      paint: {
        "circle-radius": ifFeatureStateElse('hover', 50, 25),
        "circle-color": ifFeatureStateElse('hover', 'red', 'green'),
        "circle-opacity": ifFeatureStateElse('hover', 0.8, 0.5),
      },
      // filter: ['==', ['get', 'value'], 'abc'],
    })

    // Highlighting is done by setting the "hover" state of a feature to "true"
    const highlight = (feature: MapboxGeoJSONFeature) => {
      this.map?.setFeatureState(feature, { hover: true })
    }

    // Removing the highlight is done either by setting the "hover" state to "false"
    // or by completely removing the assiciated state in which case the "fallback"
    // in "boolean" filters will kick in and provide the "false" value without having
    // to store it
    const unhighlight = (feature: MapboxGeoJSONFeature) => {
      // set hover: false
      this.map?.setFeatureState(feature, { hover: false })
      // or remove the feature state completely
      this.map?.removeFeatureState({ id: feature.id, source: feature.source })
    }

    // Extracts the first feature from the given event
    function featureFromEvent(event: { features?: MapboxGeoJSONFeature[] }) {
      return event?.features && event?.features.length > 0 ? event.features[0] : null
    }

    // This is an array holding a list of all currently highlighted features (as in "markers")
    // It'd be awesome if we could query the list of highlighted features directly from the layer
    // but unfortunately it doesn't work. See the note about error message in 'mouseout' handler
    let highlightedFeature: Nullable<MapboxGeoJSONFeature> = null

    // The "mouseover" and "mouseout" events are kind enough to provide us with the list
    // of features that have been hovered by the user

    // When the user enters with the mouse over a particular feature we want to get
    // a list of all the features that have been touched
    this.map?.on('mouseover', 'markers', e => {
      // This is how we're getting the first feature that has been hovered
      highlightedFeature = featureFromEvent(e)
      // Now let's ensure it is highlighted
      if (highlightedFeature) highlight(highlightedFeature)
    })
    this.map?.on('mouseout', 'markers', e => {
      // Unfortunately this doesn't work. It throws the following exception:
      //
      // Error: querySourceFeatures.filter: "feature-state" data expressions are not supported with filters.
      //
      // const highlightedFeatures = this.map?.querySourceFeatures('markers', {
      //   sourceLayer: 'markers',
      //   filter: [ '==', [ 'feature-state', 'hover' ], true ]
      // })

      // If by any chance we did store a reference to the currently highlighted marker
      // we shall unhighlight it and remove all traces of that previous information at once!
      if (highlightedFeature) {
        unhighlight(highlightedFeature)
        highlightedFeature = null
      }
    })

    // The "click" event isn't as gentle with the developer
    // and requires us to query the features from the given layers
    this.map?.on('click', e => {
      const feature = featureFromEvent({ features: this.map?.queryRenderedFeatures(e.point, { layers: ['markers'] }) })
      if (feature) {
        console.log('Feature', feature, 'clicked')
      } else {
        console.log('Clicked on nothing at', e.point)
      }
    })
  },
  beforeUnmount() {
    this.map?.remove()
  },
})
</script>

<style>
html,
body {
  margin: 0;
  padding: 0;
}

.map {
  height: 100vh;
}
</style>
